from string import Template

# See https://www.obj-sys.com/docs/xbv23/CCppUsersGuide/ch04.html.
atomic_builtins = {
	"string": "const char *",
	"boolean": "bool",
	"float": "float",
	"decimal": "int",
	"integer": "int",
	"nonPositiveInteger": "int",
	"negativeInteger": "int",
	"long": "long",
	"int": "int",
	"short": "short",
	"byte": "char",
	"nonNegativeInteger": "unsigned int",
	"unsignedLong": "unsigned long",
	"unsignedInt": "unsigned int",
	"unsignedShort": "unsigned short",
	"unsignedByte": "unsigned byte",
	"positiveInteger": "unsigned int",
	"double": "double",
	"IDREF": "const char *",
	"ID": "const char *",
	"NCName": "const char *",
}

atomic_builtin_load_formats = {
	"string": "char_pool.add(%s)",
	"boolean": "std::strtol(%s, NULL, 10)",
	"float": "std::strtof(%s, NULL)",
	"decimal": "std::strtol(%s, NULL, 10)",
	"integer": "std::strtol(%s, NULL, 10)",
	"nonPositiveInteger": "std::strtol(%s, NULL, 10)",
	"negativeInteger": "std::strtol(%s, NULL, 10)",
	"long": "std::strtoll(%s, NULL, 10)",
	"int": "std::strtol(%s, NULL, 10)",
	"short": "std::strtol(%s, NULL, 10)",
	"byte": "std::strtol(%s, NULL, 10)",
	"nonNegativeInteger": "std::strtoul(%s, NULL, 10)",
	"unsignedLong": "std::strtoull(%s, NULL, 10)",
	"unsignedInt": "std::strtoul(%s, NULL, 10)",
	"unsignedShort": "std::strtoul(%s, NULL, 10)",
	"unsignedByte": "std::strtoul(%s, NULL, 10)",
	"positiveInteger": "std::strtoul(%s, NULL, 10)",
	"double": "std::strtod(%s, NULL)",
	"IDREF": "char_pool.add(%s)",
	"ID": "char_pool.add(%s)",
	"NCName": "char_pool.add(%s)",
}

cpp_keywords = ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept",
			"auto", "bitand", "bitor", "bool", "break", "case", "catch", "char", "char8_t", "char16_t", "char32_t", "class",
			"compl", "concept", "const", "consteval", "constexpr", "const_cast", "continue", "co_await", "co_return",
			"co_yield", "decltype", "default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit",
			"export", "extern", "false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
			"namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "private",
			"protected", "public", "reflexpr", "register", "reinterpret_cast", "requires", "return", "short", "signed",
			"sizeof", "static", "static_assert", "static_cast", "struct", "switch", "synchronized", "template", "this",
			"thread_local", "throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned", "using",
			"virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq"]

header_comment = Template("""#pragma once
/*
 * This file is generated by uxsdcxx $version.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: $cmdline
 * Input file: $input_file
 * md5sum of input file: $md5
 */

#include <functional>

""")

impl_comment = Template("""/*
 * This file is generated by uxsdcxx $version.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: $cmdline
 * Input file: $input_file
 * md5sum of input file: $md5
 */
""")

includes = """
#include <bitset>
#include <cassert>
#include <cstring>
#include <iostream>
#include <sstream>
#include <memory>
#include <string>
#include <vector>

#include <error.h>
#include <stddef.h>
#include <stdint.h>
#include "pugixml.hpp"

"""

dfa_error_decl = """
/**
 * Internal error function for xs:choice and xs:sequence validators.
 */
[[noreturn]] inline void dfa_error(const char *wrong, const int *states, const char * const *lookup, int len, const std::function<void(const char *)> * report_error);
"""

all_error_decl = """
/**
 * Internal error function for xs:all validators.
 */
template<std::size_t N>
[[noreturn]] inline void all_error(std::bitset<N> gstate, const char * const *lookup, const std::function<void(const char *)> * report_error);
"""

attr_error_decl = """
/**
 * Internal error function for attribute validators.
 */
template<std::size_t N>
[[noreturn]] inline void attr_error(std::bitset<N> astate, const char * const *lookup, const std::function<void(const char *)> * report_error);
"""

get_line_number_decl = """
/**
 * Internal function for getting line and column number from file based on
 * byte offset.
 */
inline void get_line_number(const char *filename, std::ptrdiff_t offset, int * line, int * col);
"""

dfa_error_defn = """
inline void dfa_error(const char *wrong, const int *states, const char * const *lookup, int len, const std::function<void(const char *)> * report_error){
	std::vector<std::string> expected;
	for(int i=0; i<len; i++){
		if(states[i] != -1) expected.push_back(lookup[i]);
	}

	std::string expected_or = expected[0];
	for(unsigned int i=1; i<expected.size(); i++)
		expected_or += std::string(" or ") + expected[i];

	noreturn_report(report_error, ("Expected " + expected_or + ", found " + std::string(wrong)).c_str());
}
"""

all_error_defn = """
template<std::size_t N>
inline void all_error(std::bitset<N> gstate, const char * const *lookup, const std::function<void(const char *)> * report_error){
	std::vector<std::string> missing;
	for(unsigned int i=0; i<N; i++){
		if(gstate[i] == 0) missing.push_back(lookup[i]);
	}

	std::string missing_and = missing[0];
	for(unsigned int i=1; i<missing.size(); i++)
		missing_and += std::string(", ") + missing[i];

	noreturn_report(report_error, ("Didn't find required elements " + missing_and + ".").c_str());
}
"""

attr_error_defn = """
template<std::size_t N>
inline void attr_error(std::bitset<N> astate, const char * const *lookup, const std::function<void(const char *)> * report_error){
	std::vector<std::string> missing;
	for(unsigned int i=0; i<N; i++){
		if(astate[i] == 0) missing.push_back(lookup[i]);
	}

	std::string missing_and = missing[0];
	for(unsigned int i=1; i<missing.size(); i++)
		missing_and += std::string(", ") + missing[i];

	noreturn_report(report_error, ("Didn't find required attributes " + missing_and + ".").c_str());
}
"""

get_line_number_defn = """
inline void get_line_number(const char *filename, std::ptrdiff_t target_offset, int * line, int * col) {
	FILE* f = fopen(filename, "rb");

	if (f == nullptr) {
		throw std::runtime_error(std::string("Failed to open file") + filename);
	}

	int current_line = 1;
	std::ptrdiff_t offset = 0;
	std::ptrdiff_t last_line_offset = 0;
	std::ptrdiff_t current_line_offset = 0;

	char buffer[1024];
	std::size_t size;

	while ((size = fread(buffer, 1, sizeof(buffer), f)) > 0) {
		for (std::size_t i = 0; i < size; ++i) {
			if (buffer[i] == '\\n') {
				current_line += 1;
				last_line_offset = current_line_offset;
				current_line_offset = offset + i;

				if(target_offset < current_line_offset) {
					if(target_offset < last_line_offset) {
						throw std::runtime_error("Assertion violation");
					}

					*line = current_line - 1;
					*col = target_offset - last_line_offset;
					return;
				}
			}
		}

		offset += size;
	}

	*line = current_line;
	*col = target_offset - current_line_offset;
	fclose(f);
}
"""

report_error_decl = """
[[noreturn]] inline void noreturn_report(const std::function<void(const char *)> * report_error, const char *msg) {
    (*report_error)(msg);
    throw std::runtime_error("Unreachable!");
}
"""
