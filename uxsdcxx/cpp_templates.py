# Large dicts, arrays and strings about C++ are placed here.

# See https://www.obj-sys.com/docs/xbv23/CCppUsersGuide/ch04.html.
atomic_builtins = {
	"string": "const char *",
	"boolean": "bool",
	"float": "float",
	"decimal": "int",
	"integer": "int",
	"nonPositiveInteger": "int",
	"negativeInteger": "int",
	"long": "long",
	"int": "int",
	"short": "short",
	"byte": "char",
	"nonNegativeInteger": "unsigned int",
	"unsignedLong": "unsigned long",
	"unsignedInt": "unsigned int",
	"unsignedShort": "unsigned short",
	"unsignedByte": "unsigned byte",
	"positiveInteger": "unsigned int",
	"double": "double",
	"IDREF": "const char *",
	"ID": "const char *",
	"NCName": "const char *",
}

atomic_builtin_load_formats = {
	"string": "char_pool.add(%s)",
	"boolean": "std::strtol(%s, NULL, 10)",
	"float": "std::strtof(%s, NULL)",
	"decimal": "std::strtol(%s, NULL, 10)",
	"integer": "std::strtol(%s, NULL, 10)",
	"nonPositiveInteger": "std::strtol(%s, NULL, 10)",
	"negativeInteger": "std::strtol(%s, NULL, 10)",
	"long": "std::strtoll(%s, NULL, 10)",
	"int": "std::strtol(%s, NULL, 10)",
	"short": "std::strtol(%s, NULL, 10)",
	"byte": "std::strtol(%s, NULL, 10)",
	"nonNegativeInteger": "std::strtoul(%s, NULL, 10)",
	"unsignedLong": "std::strtoull(%s, NULL, 10)",
	"unsignedInt": "std::strtoul(%s, NULL, 10)",
	"unsignedShort": "std::strtoul(%s, NULL, 10)",
	"unsignedByte": "std::strtoul(%s, NULL, 10)",
	"positiveInteger": "std::strtoul(%s, NULL, 10)",
	"double": "std::strtod(%s, NULL)",
	"IDREF": "char_pool.add(%s)",
	"ID": "char_pool.add(%s)",
	"NCName": "char_pool.add(%s)",
}

cpp_keywords = [
	"alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit",
	"atomic_noexcept", "auto", "bitand", "bitor", "bool", "break", "case", "catch",
	"char", "char8_t", "char16_t", "char32_t", "class", "compl", "concept", "const",
	"consteval", "constexpr", "const_cast", "continue", "co_await", "co_return",
	"co_yield", "decltype", "default", "delete", "do", "double", "dynamic_cast",
	"else", "enum", "explicit", "export", "extern", "false", "float", "for", "friend",
	"goto", "if", "inline", "int", "long", "mutable", "namespace", "new", "noexcept",
	"not", "not_eq", "nullptr", "operator", "or", "or_eq", "private", "protected",
	"public", "reflexpr", "register", "reinterpret_cast", "requires", "return", "short",
	"signed", "sizeof", "static", "static_assert", "static_cast", "struct", "switch",
	"synchronized", "template", "this", "thread_local", "throw", "true", "try",
	"typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void",
	"volatile", "wchar_t", "while", "xor", "xor_eq"
]

header_comment = """#pragma once
/*
 * This file is generated by uxsdcxx {version}.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: {cmdline}
 * Input file: {input_file}
 * md5sum of input file: {md5}
 */
"""

includes = """
#include <bitset>
#include <cassert>
#include <cstring>
#include <functional>
#include <iostream>
#include <sstream>
#include <memory>
#include <string>
#include <vector>

#include <stddef.h>
#include <stdint.h>
#include "pugixml.hpp"

"""


load_root_element_defn = """
template <class T, typename Context>
inline void load_{name}_xml(T &out, Context &context, const char * filename, std::istream &is){{
	pugi::xml_document doc;
	pugi::xml_parse_result result = doc.load(is);
	if(!result) {{
		int line, col;
		get_line_number(filename, result.offset, &line, &col);
		std::stringstream msg;
		msg << "Unable to load XML file '" << filename << "', ";
		msg << result.description() << " (line: " << line;
		msg << " col: " << col << ")";		out.error_encountered(filename, line, msg.str().c_str());
	}}
	ptrdiff_t offset_debug = 0;
	std::function<void(const char *)> report_error = [filename, &out, &offset_debug](const char * message) {{
		int line, col;
		get_line_number(filename, offset_debug, &line, &col);
		out.error_encountered(filename, line, message);
		// If error_encountered didn't throw, throw now to unwind.
		throw std::runtime_error(message);
	}};
	out.start_load(&report_error);

	for(pugi::xml_node node= doc.first_child(); node; node = node.next_sibling()){{
		if(std::strcmp(node.name(), "{name}") == 0){{
			/* If errno is set up to this point, it messes with strtol errno checking. */
			errno = 0;
			load_{type}(node, out, context, &report_error, &offset_debug);
		}} else {{
			offset_debug = node.offset_debug();
			report_error(("Invalid root-level element " + std::string(node.name())).c_str());
		}}
	}}
	out.finish_load();
}}
"""

load_complex_type_decl = """template <class T, typename Context>
inline void load_{name}(const pugi::xml_node &root, T &out, Context &context, const std::function<void(const char*)> *report_error, ptrdiff_t *offset_debug);"""

load_required_attrs_decl = "inline void load_{name}_required_attributes(const pugi::xml_node &root, {args}, const std::function<void(const char*)> * report_error);"

write_complex_type_decl = """template <class T>
inline void write_{name}(T &in, std::ostream &os, const void *data, void *iter);"""


dfa_error_decl = """
/**
 * Internal error function for xs:choice and xs:sequence validators.
 */
[[noreturn]] inline void dfa_error(const char *wrong, const int *states, const char * const *lookup, int len, const std::function<void(const char *)> * report_error);
"""

all_error_decl = """
/**
 * Internal error function for xs:all validators.
 */
template<std::size_t N>
[[noreturn]] inline void all_error(std::bitset<N> gstate, const char * const *lookup, const std::function<void(const char *)> * report_error);
"""

attr_error_decl = """
/**
 * Internal error function for attribute validators.
 */
template<std::size_t N>
[[noreturn]] inline void attr_error(std::bitset<N> astate, const char * const *lookup, const std::function<void(const char *)> * report_error);
"""

get_line_number_decl = """
/**
 * Internal function for getting line and column number from file based on
 * byte offset.
 */
inline void get_line_number(const char *filename, std::ptrdiff_t offset, int * line, int * col);
"""

dfa_error_defn = """
inline void dfa_error(const char *wrong, const int *states, const char * const *lookup, int len, const std::function<void(const char *)> * report_error){
	std::vector<std::string> expected;
	for(int i=0; i<len; i++){
		if(states[i] != -1) expected.push_back(lookup[i]);
	}

	std::string expected_or = expected[0];
	for(unsigned int i=1; i<expected.size(); i++)
		expected_or += std::string(" or ") + expected[i];

	noreturn_report(report_error, ("Expected " + expected_or + ", found " + std::string(wrong)).c_str());
}
"""

all_error_defn = """
template<std::size_t N>
inline void all_error(std::bitset<N> gstate, const char * const *lookup, const std::function<void(const char *)> * report_error){
	std::vector<std::string> missing;
	for(unsigned int i=0; i<N; i++){
		if(gstate[i] == 0) missing.push_back(lookup[i]);
	}

	std::string missing_and = missing[0];
	for(unsigned int i=1; i<missing.size(); i++)
		missing_and += std::string(", ") + missing[i];

	noreturn_report(report_error, ("Didn't find required elements " + missing_and + ".").c_str());
}
"""

attr_error_defn = """
template<std::size_t N>
inline void attr_error(std::bitset<N> astate, const char * const *lookup, const std::function<void(const char *)> * report_error){
	std::vector<std::string> missing;
	for(unsigned int i=0; i<N; i++){
		if(astate[i] == 0) missing.push_back(lookup[i]);
	}

	std::string missing_and = missing[0];
	for(unsigned int i=1; i<missing.size(); i++)
		missing_and += std::string(", ") + missing[i];

	noreturn_report(report_error, ("Didn't find required attributes " + missing_and + ".").c_str());
}
"""

get_line_number_defn = """
inline void get_line_number(const char *filename, std::ptrdiff_t target_offset, int * line, int * col) {
	std::unique_ptr<FILE,decltype(&fclose)> f(fopen(filename, "rb"), fclose);

	if (!f) {
		throw std::runtime_error(std::string("Failed to open file") + filename);
	}

	int current_line = 1;
	std::ptrdiff_t offset = 0;
	std::ptrdiff_t last_line_offset = 0;
	std::ptrdiff_t current_line_offset = 0;

	char buffer[1024];
	std::size_t size;

	while ((size = fread(buffer, 1, sizeof(buffer), f.get())) > 0) {
		for (std::size_t i = 0; i < size; ++i) {
			if (buffer[i] == '\\n') {
				current_line += 1;
				last_line_offset = current_line_offset;
				current_line_offset = offset + i;

				if(target_offset < current_line_offset) {
					if(target_offset < last_line_offset) {
						throw std::runtime_error("Assertion violation");
					}

					*line = current_line - 1;
					*col = target_offset - last_line_offset;
					return;
				}
			}
		}

		offset += size;
	}

	*line = current_line;
	*col = target_offset - current_line_offset;
}
"""

report_error_decl = """
[[noreturn]] inline void noreturn_report(const std::function<void(const char *)> * report_error, const char *msg) {
	(*report_error)(msg);
	throw std::runtime_error("Unreachable!");
}
"""
